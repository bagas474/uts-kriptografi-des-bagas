# -*- coding: utf-8 -*-
"""UTS_Kriptografi_Ahmad Bagas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11mMv0AP94w7Q3I0S_z3oWPGPh3dhyics

# DES GAMBAR

## Base Table
"""

INITIAL_PERM = [58, 50, 42, 34, 26, 18, 10, 2,
                60, 52, 44, 36, 28, 20, 12, 4,
                62, 54, 46, 38, 30, 22, 14, 6,
                64, 56, 48, 40, 32, 24, 16, 8,
                57, 49, 41, 33, 25, 17, 9, 1,
                59, 51, 43, 35, 27, 19, 11, 3,
                61, 53, 45, 37, 29, 21, 13, 5,
                63, 55, 47, 39, 31, 23, 15, 7]

FINAL_PERM = [40, 8, 48, 16, 56, 24, 64, 32,
              39, 7, 47, 15, 55, 23, 63, 31,
              38, 6, 46, 14, 54, 22, 62, 30,
              37, 5, 45, 13, 53, 21, 61, 29,
              36, 4, 44, 12, 52, 20, 60, 28,
              35, 3, 43, 11, 51, 19, 59, 27,
              34, 2, 42, 10, 50, 18, 58, 26,
              33, 1, 41, 9, 49, 17, 57, 25]

EXPAND_TABLE = [32, 1, 2, 3, 4, 5,
                4, 5, 6, 7, 8, 9,
                8, 9, 10, 11, 12, 13,
                12, 13, 14, 15, 16, 17,
                16, 17, 18, 19, 20, 21,
                20, 21, 22, 23, 24, 25,
                24, 25, 26, 27, 28, 29,
                28, 29, 30, 31, 32, 1]

SUB_BOXES = [
    # S1
    [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
     [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
     [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
     [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],

    # S2
    [[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
     [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
     [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
     [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],

    # S3
    [[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
     [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
     [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
     [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],

    # S4
    [[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
     [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
     [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
     [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],

    # S5
    [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
     [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
     [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
     [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],

    # S6
    [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
     [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
     [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
     [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],

    # S7
    [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
     [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
     [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
     [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],

    # S8
    [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
     [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
     [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
     [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]
]

PERM_TABLE = [16, 7, 20, 21, 29, 12, 28, 17,
              1, 15, 23, 26, 5, 18, 31, 10,
              2, 8, 24, 14, 32, 27, 3, 9,
              19, 13, 30, 6, 22, 11, 4, 25]

PC1 = [57, 49, 41, 33, 25, 17, 9,
       1, 58, 50, 42, 34, 26, 18,
       10, 2, 59, 51, 43, 35, 27,
       19, 11, 3, 60, 52, 44, 36,
       63, 55, 47, 39, 31, 23, 15,
       7, 62, 54, 46, 38, 30, 22,
       14, 6, 61, 53, 45, 37, 29,
       21, 13, 5, 28, 20, 12, 4]

SHIFT_AMOUNTS = [1, 1, 2, 2, 2, 2, 2, 2,
                 1, 2, 2, 2, 2, 2, 2, 1]

PC2 = [14, 17, 11, 24, 1, 5,
       3, 28, 15, 6, 21, 10,
       23, 19, 12, 4, 26, 8,
       16, 7, 27, 20, 13, 2,
       41, 52, 31, 37, 47, 55,
       30, 40, 51, 45, 33, 48,
       44, 49, 39, 56, 34, 53,
       46, 42, 50, 36, 29, 32]

"""## Base DES Program"""

def permute_bits(block, table):
    return ''.join([block[i - 1] for i in table])

def xor_bits(a, b):
    return ''.join(['0' if i == j else '1' for i, j in zip(a, b)])

def sbox_substitution(bits, sbox_idx):
    sbox = SUB_BOXES[sbox_idx]
    row = int(bits[0] + bits[5], 2)
    col = int(bits[1:5], 2)
    return format(sbox[row][col], '04b')

def split_in_half(data):
    half = len(data) // 2
    return data[:half], data[half:]

def group_binary_string(binary_str, group_size):
    return ' '.join([binary_str[i:i + group_size] for i in range(0, len(binary_str), group_size)])

# Key schedule to generate round keys
def generate_keys(key_input):
    key = permute_bits(key_input, PC1)
    C_part, D_part = split_in_half(key)
    round_keys = []

    for round_num in range(16):
        C_part = C_part[SHIFT_AMOUNTS[round_num]:] + C_part[:SHIFT_AMOUNTS[round_num]]
        D_part = D_part[SHIFT_AMOUNTS[round_num]:] + D_part[:SHIFT_AMOUNTS[round_num]]
        round_key = permute_bits(C_part + D_part, PC2)
        round_keys.append(round_key)

    return round_keys

# DES function for 16 rounds
def des_function(R_half, key_round):
    expanded_R = permute_bits(R_half, EXPAND_TABLE)

    # XOR step
    result_xor = xor_bits(expanded_R, key_round)

    # S-box transformation
    sbox_result = ''
    for box_num in range(8):
        six_bit_block = result_xor[box_num * 6: (box_num + 1) * 6]
        sbox_result += sbox_substitution(six_bit_block, box_num)

    # Final permutation for this round
    return permute_bits(sbox_result, PERM_TABLE)

"""## Base DES Encryption & Decryption Program"""

def des_encrypt(data_input, key_input):
    # Initial permutation
    permuted_data = permute_bits(data_input, INITIAL_PERM)
    L_half, R_half = split_in_half(permuted_data)

    # Generate round keys
    keys = generate_keys(key_input)

    # 16 rounds
    for round_idx, round_key in enumerate(keys):
        # DES function for this round
        round_output = des_function(R_half, round_key)
        new_R_half = xor_bits(L_half, round_output)
        L_half = R_half
        R_half = new_R_half

    return permute_bits(R_half + L_half, FINAL_PERM)

def des_decrypt(cipher_text, decryption_key):
    # Initial permutation
    permuted_text = permute_bits(cipher_text, INITIAL_PERM)
    left_half, right_half = split_in_half(permuted_text)

    # Generate 16 round keys (in reverse order for decryption)
    round_keys = generate_keys(decryption_key)

    # 16 rounds of DES decryption (keys used in reverse)
    for round_num in range(15, -1, -1):
        temp_right = right_half
        right_half = xor_bits(left_half, des_function(right_half, round_keys[round_num]))
        left_half = temp_right

    return permute_bits(right_half + left_half, FINAL_PERM)

"""## Image Encryption"""

from PIL import Image
import numpy as np

image_path = 'bagas.png'
key_input = '0011010000110110001100010011000100110100001100100011001000110000'

height, width, channels = 160, 120, 3
img_arr_length = height * width * channels
shape = (height, width, channels)

from PIL import Image
import numpy as np

def rm_ws(text):
    # Menghilangkan whitespace
    return text.replace(" ", "")

image_path = 'bagas.png'
key_input = rm_ws('00110100 00110110 00110001 00110001 00110100 00110010 00110010 00110000')  # 64-bit key

height, width, channels = 160, 120, 3
img_arr_length = height * width * channels
shape = (height, width, channels)

# Helper function to convert image to binary data
def image_to_binary(image_path):
    with Image.open(image_path) as img:
        img = img.convert('RGB')  # Ensure the image is in RGB format
        arr = np.array(img)
        # Flatten the array and convert it to bytes
        binary_data = arr.flatten()
    return binary_data

bin_img = image_to_binary(image_path)

def int_to_binary_string(num):
    # Convert the number to a binary string, remove the '0b' prefix, and pad with zeros
    binary_string = bin(num)[2:].zfill(8)
    return str(binary_string)

def to_binary_strings(numbers_abc):
  binary_strings = []
  for num_abc in numbers_abc:
    binary_string = int_to_binary_string(num_abc)
    binary_strings.append(binary_string)
  return binary_strings

# Example usage
binary_strings = np.array(to_binary_strings(bin_img))

def group_elements_w(arr):
    # Ensure arr contains only strings (in case you have integers)
    arr = [str(x) for x in arr]

    # Convert elements to a string and concatenate them
    grouped = [''.join(arr[i:i+8]) for i in range(0, len(arr), 8)]

    # If the last group is not 8 characters long, pad it with '0'
    if len(grouped[-1]) < 8:
        grouped[-1] = grouped[-1].ljust(8, '0')

    return grouped

grouped_elements = group_elements_w(binary_strings)

arr_img_encrypted = []

for binary_string in grouped_elements:
    encrypted_chunk = des_encrypt(binary_string, key_input)
    arr_img_encrypted.append(encrypted_chunk)

def parse_binary_string_every_8_char(binary_string, group_size=8):
    # Split the string into chunks of 8 characters each
    return [binary_string[i:i+group_size] for i in range(0, len(binary_string), group_size)]


arr_img_encrypted_parsed_8 = []

for encrypted_chunk in arr_img_encrypted:
    parsed_chunk = parse_binary_string_every_8_char(encrypted_chunk)
    arr_img_encrypted_parsed_8.append(parsed_chunk)

def binary_string_to_int(nested_list):
    # Iterate through each sublist in the nested list
    return [[int(binary_str, 2) for binary_str in sublist] for sublist in nested_list]

img_encrypted_flat = binary_string_to_int(arr_img_encrypted_parsed_8)
img_encrypted_flat = np.array(img_encrypted_flat)
img_encrypted_flat = img_encrypted_flat.flatten()
img_encrypted_flat = img_encrypted_flat.reshape(shape)

from PIL import Image
import numpy as np

# Example NumPy array (160, 120, 3) - Normally this array would contain image data
array = img_encrypted_flat

array = array.astype(np.uint8)

# Convert the NumPy array to an image
image = Image.fromarray(array)

# Save the image as a .jpg file
image.save("encrypted_image.png")

# To display the image (optional)
image.show()

"""## Dekripsi"""

image_path = 'encrypted_image.png'

height, width, channels = 160, 120, 3
img_arr_length = height * width * channels
shape = (height, width, channels)  # This should be set to the original image dimensions

def des_decrypt(cipher_text, decryption_key):
    # Initial permutation
    permuted_text = permute_bits(cipher_text, INITIAL_PERM)
    left_half, right_half = split_in_half(permuted_text)

    # Generate 16 round keys (in reverse order for decryption)
    round_keys = generate_keys(decryption_key)

    # 16 rounds of DES decryption (keys used in reverse)
    for round_num in range(15, -1, -1):
        temp_right = right_half
        right_half = xor_bits(left_half, des_function(right_half, round_keys[round_num]))
        left_half = temp_right

    return permute_bits(right_half + left_half, FINAL_PERM)

bin_img = image_to_binary(image_path)
binary_strings = np.array(to_binary_strings(bin_img))

grouped_elements = group_elements_w(binary_strings)
print(grouped_elements)

def parse_binary_string_every_8_char(binary_string, group_size=8):
    # Split the string into chunks of 8 characters each
    return [binary_string[i:i+group_size] for i in range(0, len(binary_string), group_size)]

arr_img_decrypted = []

for binary_string in grouped_elements:
    encrypted_chunk = des_decrypt(binary_string, key_input)
    arr_img_decrypted.append(encrypted_chunk)

arr_img_decrypted_parsed_8 = []

for decrypted_chunk in arr_img_decrypted:
    parsed_chunk = parse_binary_string_every_8_char(decrypted_chunk)
    arr_img_decrypted_parsed_8.append(parsed_chunk)

img_decrypted_flat = binary_string_to_int(arr_img_decrypted_parsed_8)
img_decrypted_flat = np.array(img_decrypted_flat)
img_decrypted_flat = img_decrypted_flat.flatten()
img_decrypted_flat = img_decrypted_flat.reshape(shape)
img_decrypted_flat


# Example NumPy array (160, 120, 3) - Normally this array would contain image data
array = img_decrypted_flat

array = array.astype(np.uint8)

# Convert the NumPy array to an image
image = Image.fromarray(array)

# Save the image as a .jpg file
image.save("decrypted_image.png")

# To display the image (optional)
image.show()

"""# DES AUDIO"""

pip install pydub pycryptodome

from pydub import AudioSegment
from Crypto.Cipher import DES
import os

# Fungsi untuk memuat audio WAV sebagai bytes
def load_wav_as_bytes(file_path):
    audio = AudioSegment.from_wav(file_path)
    return audio.raw_data, audio.frame_rate, audio.sample_width, audio.channels

# Fungsi untuk menyimpan bytes kembali ke file WAV
def save_bytes_as_wav(file_path, audio_bytes, frame_rate, sample_width, channels):
    audio = AudioSegment(
        data=audio_bytes,
        frame_rate=frame_rate,
        sample_width=sample_width,
        channels=channels
    )
    audio.export(file_path, format="wav")

# Fungsi untuk menambahkan padding agar panjang data kelipatan 8 byte
def pad(data):
    while len(data) % 8 != 0:
        data += b' '
    return data

# Fungsi enkripsi DES
def des_encrypt(key, data):
    cipher = DES.new(key, DES.MODE_ECB)
    padded_data = pad(data)
    encrypted_data = cipher.encrypt(padded_data)
    return encrypted_data

# Fungsi dekripsi DES
def des_decrypt(key, encrypted_data):
    cipher = DES.new(key, DES.MODE_ECB)
    decrypted_data = cipher.decrypt(encrypted_data)
    return decrypted_data.rstrip(b' ')  # Hapus padding di akhir

# Contoh penggunaan:
input_wav = 'indonesia.wav'
encrypted_wav = 'encrypted_audio.wav'
decrypted_wav = 'decrypted_audio.wav'

# Muat file WAV sebagai bytes
audio_bytes, frame_rate, sample_width, channels = load_wav_as_bytes(input_wav)

# Kunci DES (8 bytes)
key = b'46114220'  # Ganti dengan kunci 8 byte yang aman

# Enkripsi audio
encrypted_audio = des_encrypt(key, audio_bytes)

# Simpan hasil enkripsi ke file WAV (dalam bentuk bytes terenkripsi)
save_bytes_as_wav(encrypted_wav, encrypted_audio, frame_rate, sample_width, channels)

# Dekripsi audio
decrypted_audio = des_decrypt(key, encrypted_audio)

# Simpan hasil dekripsi ke file WAV
save_bytes_as_wav(decrypted_wav, decrypted_audio, frame_rate, sample_width, channels)

print("Proses enkripsi dan dekripsi selesai.")

"""# DES VIDEO"""

from moviepy.editor import VideoFileClip
from Crypto.Cipher import DES
import os

# Fungsi untuk membaca video dalam bentuk bytes
def load_video_as_bytes(file_path):
    with open(file_path, 'rb') as file:
        video_bytes = file.read()
    return video_bytes

# Fungsi untuk menyimpan bytes kembali ke file video
def save_bytes_as_video(file_path, video_bytes):
    with open(file_path, 'wb') as file:
        file.write(video_bytes)

# Fungsi untuk menambahkan padding agar panjang data kelipatan 8 byte
def pad(data):
    while len(data) % 8 != 0:
        data += b' '
    return data

# Fungsi enkripsi DES
def des_encrypt(key, data):
    cipher = DES.new(key, DES.MODE_ECB)
    padded_data = pad(data)
    encrypted_data = cipher.encrypt(padded_data)
    return encrypted_data

# Fungsi dekripsi DES
def des_decrypt(key, encrypted_data):
    cipher = DES.new(key, DES.MODE_ECB)
    decrypted_data = cipher.decrypt(encrypted_data)
    return decrypted_data.rstrip(b' ')  # Hapus padding di akhir

# Contoh penggunaan:
input_video = 'marsunnes.mp4'
encrypted_video = 'encrypted_video.mp4'
decrypted_video = 'decrypted_video.mp4'

# Muat file video sebagai bytes
video_bytes = load_video_as_bytes(input_video)

# Kunci DES (8 bytes)
key = b'8bytekey'  # Ganti dengan kunci 8 byte yang aman

# Enkripsi video
encrypted_video_bytes = des_encrypt(key, video_bytes)

# Simpan hasil enkripsi ke file video
save_bytes_as_video(encrypted_video, encrypted_video_bytes)

# Dekripsi video
decrypted_video_bytes = des_decrypt(key, encrypted_video_bytes)

# Simpan hasil dekripsi ke file video
save_bytes_as_video(decrypted_video, decrypted_video_bytes)

print("Proses enkripsi dan dekripsi video selesai.")